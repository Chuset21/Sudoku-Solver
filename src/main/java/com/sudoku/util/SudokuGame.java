package com.sudoku.util;

import com.copy.Copy;

public class SudokuGame {
    private final byte[][] grid;
    private Tuple<Byte, Byte> lastPosition;

    public static final byte GRID_BOUNDARY = 9;

    /**
     * In the future the grid will be generated by an algorithm.
     */
    public SudokuGame() {
        grid = new byte[][]{
                {7, 8, 0, 4, 0, 0, 1, 2, 0},
                {6, 0, 0, 0, 7, 5, 0, 0, 9},
                {0, 0, 0, 6, 0, 1, 0, 7, 8},
                {0, 0, 7, 0, 4, 0, 2, 6, 0},
                {0, 0, 1, 0, 5, 0, 9, 3, 0},
                {9, 0, 4, 0, 6, 0, 0, 0, 5},
                {0, 7, 0, 3, 0, 0, 0, 1, 2},
                {1, 2, 0, 0, 0, 7, 4, 0, 0},
                {0, 4, 9, 2, 0, 6, 0, 0, 7}
        };
        lastPosition = new Tuple<>((byte) 0, (byte) 0);
    }

    public byte[][] getCopyOfGrid() {
        return Copy.deepCopy(grid);
    }

    private static record Tuple<X, Y>(X row, Y col) {
    }

    private Tuple<Byte, Byte> findEmpty() {
        for (byte i = lastPosition.row; i < GRID_BOUNDARY; i++) {
            for (byte j = i == lastPosition.row ? lastPosition.col : 0; j < GRID_BOUNDARY; j++) {
                if (grid[i][j] == 0) {
                    return new Tuple<>(i, j); // row, col
                }
            }
        }
        return null;
    }

    private boolean isValid(byte number, Tuple<Byte, Byte> position) {
        // Check row
        for (byte i = 0; i < GRID_BOUNDARY; i++) {
            if (position.col != i && grid[position.row][i] == number) {
                return false;
            }
        }

        // Check column
        for (byte i = 0; i < GRID_BOUNDARY; i++) {
            if (position.row != i && grid[i][position.col] == number) {
                return false;
            }
        }

        // Check cubes
        final int boxX = position.col / 3;
        final int boxY = position.row / 3;

        final int iStart = boxY * 3;
        final int iEnd = iStart + 3;
        final int jStart = boxX * 3;
        final int jEnd = jStart + 3;

        for (int i = iStart; i < iEnd; i++) {
            for (int j = jStart; j < jEnd; j++) {
                if (i != position.row && j != position.col && grid[i][j] == number) {
                    return false;
                }
            }
        }

        return true;
    }

    public boolean solve() {
        // Base case: If all positions are filled up, the grid must have been solved
        final Tuple<Byte, Byte> position = findEmpty();
        if (position == null) {
            return true;
        }

        lastPosition = position;
        for (byte num = 1; num <= GRID_BOUNDARY; num++) {
            if (isValid(num, position)) {
                grid[position.row][position.col] = num;

                if (solve()) {
                    return true;
                }

                // If it wasn't solved and it backtracks to here
                grid[position.row][position.col] = 0;
                lastPosition = position;
            }
        }

        return false;
    }

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder();

        final byte limit = GRID_BOUNDARY - 1;
        for (byte i = 0; i < limit; i++) {

            appendFirstEight(sb, i);

            final byte boardValue = grid[i][limit];
            sb.append(boardValue == 0 ? "?" : boardValue).append('\n');

            if ((i + 1) % 3 == 0) {
                sb.append("- - - - - - - - - - - - - -").append('\n');
            }
        }
        appendFirstEight(sb, limit);

        return sb.append(grid[limit][limit]).toString();
    }

    private void appendFirstEight(StringBuilder sb, byte row) {
        for (byte j = 0; j < 8; j++) {
            final byte boardValue = grid[row][j];
            sb.append(boardValue == 0 ? "?" : boardValue).append((j + 1) % 3 == 0 ? " | " : "  ");
        }
    }

    public static void main(String[] args) {
        final SudokuGame sudokuGame = new SudokuGame();
        System.out.println(sudokuGame);
        System.out.println();

        // Testing that the copy is deep (not shallow)
        final byte[][] copy = sudokuGame.getCopyOfGrid();
        copy[0][0] = 78;

        System.out.println(sudokuGame);
        System.out.println();

        // Testing the solve method
        sudokuGame.solve();
        System.out.println(sudokuGame);
    }
}
